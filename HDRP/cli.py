#!/usr/bin/env python3
"""
HDRP CLI

Typer/Rich-powered command-line interface for running the HDRP research
pipeline end-to-end using the Python services and pluggable search
providers (Tavily or simulated).
"""

import os
import sys
from typing import Optional

import typer
from rich.console import Console
from rich.panel import Panel

from HDRP.tools.search.factory import SearchFactory
from HDRP.tools.search.base import SearchError
from HDRP.tools.search.api_key_validator import APIKeyError
from HDRP.services.researcher.service import ResearcherService
from HDRP.services.critic.service import CriticService
from HDRP.services.synthesizer.service import SynthesizerService
from HDRP.services.shared.logger import ResearchLogger


app = typer.Typer(help="HDRP research CLI")
console = Console()


def _build_search_provider(
    provider: str,
    api_key: Optional[str],
) -> object:
    """
    Construct a search provider using the existing SearchFactory.

    - When provider == "tavily", prefer explicit api_key if given,
      otherwise fall back to TAVILY_API_KEY env var.
    - When provider == "simulated", ignore api_key.
    - When provider is omitted, delegate to SearchFactory.from_env().
    """
    provider = (provider or "").strip().lower()

    if not provider:
        # Let factory decide based on HDRP_SEARCH_PROVIDER and friends.
        return SearchFactory.from_env()

    if provider == "tavily":
        # Explicit key wins; otherwise rely on environment.
        effective_key = api_key or os.getenv("TAVILY_API_KEY")
        return SearchFactory.get_provider("tavily", api_key=effective_key)

    if provider == "simulated":
        return SearchFactory.get_provider("simulated")

    raise SystemExit(f"Unknown provider '{provider}'. Use 'tavily' or 'simulated'.")


def _run_pipeline(
    query: str,
    provider: str,
    api_key: Optional[str],
    output_path: Optional[str],
    verbose: bool,
) -> int:
    """Execute the core HDRP research → critic → synthesize pipeline."""
    # Single run_id shared across components for joined logging.
    run_logger = ResearchLogger("cli")
    run_id = run_logger.run_id

    if verbose:
        console.print(f"[bold cyan][hdrp][/bold cyan] run_id={run_id}")
        console.print(f"[bold cyan][hdrp][/bold cyan] provider={provider or 'auto'}")

    # 1. Build search provider (Tavily or simulated).
    try:
        search_provider = _build_search_provider(provider, api_key)
    except SystemExit:
        # Re-raise to allow clean exit with message
        raise
    except (SearchError, APIKeyError) as exc:
        # API key validation errors get special formatting
        console.print(Panel.fit(
            f"[bold red]Configuration Error[/bold red]\n\n{exc}",
            border_style="red",
            title="[bold]HDRP Setup Required[/bold]",
        ))
        return 1
    except Exception as exc:
        console.print(
            f"[bold red][hdrp][/bold red] Failed to initialize search provider: {exc}"
        )
        return 1

    # 2. Initialize services.
    researcher = ResearcherService(search_provider, run_id=run_id)
    critic = CriticService(run_id=run_id)
    synthesizer = SynthesizerService()

    if verbose:
        console.print(f"[bold cyan][hdrp][/bold cyan] Researching: [italic]{query}[/italic]")

    # 3. Research.
    try:
        claims = researcher.research(query, source_node_id="root_research")
    except Exception as exc:
        console.print(f"[bold red][hdrp][/bold red] Research failed: {exc}")
        return 1

    if verbose:
        console.print(f"[bold cyan][hdrp][/bold cyan] Retrieved {len(claims)} raw claims")

    if not claims:
        console.print("[yellow]No information found for this query.[/yellow]")
        return 0

    # 4. Critic: verify claims.
    critique_results = critic.verify(claims, task=query)
    verified_count = sum(1 for r in critique_results if r.is_valid)

    if verbose:
        rejected_count = len(critique_results) - verified_count
        console.print(
            f"[bold cyan][hdrp][/bold cyan] Verified={verified_count}, "
            f"Rejected={rejected_count}"
        )

    # 5. Synthesize human-readable report.
    context = {
        "report_title": f"HDRP Research Report: {query}",
        "introduction": (
            "This report was generated by the Hierarchical Deep Research Planner (HDRP) "
            "pipeline using structured claims with explicit source traceability."
        ),
    }
    report = synthesizer.synthesize(critique_results, context=context)

    if output_path:
        try:
            with open(output_path, "w", encoding="utf-8") as f:
                f.write(report)
            if verbose:
                console.print(
                    Panel.fit(
                        f"Report written to [bold]{output_path}[/bold]",
                        border_style="green",
                    )
                )
        except OSError as exc:
            console.print(
                f"[bold red][hdrp][/bold red] Failed to write report to {output_path}: {exc}"
            )
            return 1
    else:
        # Print to stdout as plain text (no Rich markup parsing).
        console.print(report, markup=False)

    return 0


@app.command()
def run(
    query: str = typer.Option(
        ...,
        "--query",
        "-q",
        help="Research query or objective to investigate.",
    ),
    mode: str = typer.Option(
        "python",
        "--mode",
        "-m",
        help="Execution mode: 'python' (direct pipeline) or 'orchestrator' (Go DAG execution).",
    ),
    provider: Optional[str] = typer.Option(
        None,
        "--provider",
        "-p",
        help=(
            "Search provider to use ('tavily' or 'simulated'). "
            "If omitted, HDRP_SEARCH_PROVIDER/TAVILY_* env vars are used."
        ),
    ),
    api_key: Optional[str] = typer.Option(
        None,
        "--api-key",
        help="Explicit API key for Tavily; overrides TAVILY_API_KEY when set.",
    ),
    output: Optional[str] = typer.Option(
        None,
        "--output",
        "-o",
        help="If provided, write the final report to this file instead of stdout.",
    ),
    verbose: bool = typer.Option(
        False,
        "--verbose",
        "-v",
        help="Enable verbose logging to the terminal.",
    ),
) -> None:
    """Run a single HDRP research query."""
    provider_display = provider or "auto"
    mode_display = mode.upper()
    
    console.print(
        Panel.fit(
            f"[bold cyan]HDRP Research[/bold cyan]\n\n"
            f"[bold]Query:[/bold] {query}\n"
            f"[bold]Mode:[/bold] {mode_display}\n"
            f"[bold]Provider:[/bold] {provider_display}",
            border_style="cyan",
        )
    )

    if mode.lower() == "orchestrator":
        from HDRP.orchestrated_runner import run_orchestrated
        exit_code = run_orchestrated(
            query=query,
            provider=provider or "",
            api_key=api_key,
            output_path=output,
            verbose=verbose,
        )
    else:
        exit_code = _run_pipeline(
            query=query,
            provider=provider or "",
            api_key=api_key,
            output_path=output,
            verbose=verbose,
        )

    raise typer.Exit(code=exit_code)


def run_query_programmatic(
    query: str,
    provider: str = "",
    api_key: Optional[str] = None,
    verbose: bool = False,
    run_id: Optional[str] = None,
    progress_callback: Optional[callable] = None,
) -> dict:
    """
    Execute a query programmatically (for dashboard integration).
    
    Args:
        query: Research query to execute
        provider: Search provider ('tavily', 'simulated', or empty for auto)
        api_key: Optional API key
        verbose: Enable verbose logging
        run_id: Optional run ID (will generate if not provided)
        progress_callback: Optional callback(stage, percent) for progress updates
        
    Returns:
        dict: {"success": bool, "run_id": str, "report": str, "error": str}
    """
    # Initialize logger with provided or generated run_id
    run_logger = ResearchLogger("cli", run_id=run_id)
    actual_run_id = run_logger.run_id
    
    try:
        # Progress update helper
        def update_progress(stage: str, percent: float):
            if progress_callback:
                progress_callback(stage, percent)
        
        update_progress("Initializing search provider", 10)
        
        # Build search provider
        try:
            search_provider = _build_search_provider(provider, api_key)
        except (SearchError, APIKeyError) as exc:
            return {
                "success": False,
                "run_id": actual_run_id,
                "report": "",
                "error": f"Configuration Error: {exc}",
            }
        except Exception as exc:
            return {
                "success": False,
                "run_id": actual_run_id,
                "report": "",
                "error": f"Failed to initialize search provider: {exc}",
            }
        
        update_progress("Initializing services", 20)
        
        # Initialize services
        researcher = ResearcherService(search_provider, run_id=actual_run_id)
        critic = CriticService(run_id=actual_run_id)
        synthesizer = SynthesizerService()
        
        update_progress(f"Researching: {query}", 30)
        
        # Research
        try:
            claims = researcher.research(query, source_node_id="root_research")
        except Exception as exc:
            return {
                "success": False,
                "run_id": actual_run_id,
                "report": "",
                "error": f"Research failed: {exc}",
            }
        
        if not claims:
            return {
                "success": True,
                "run_id": actual_run_id,
                "report": "No information found for this query.",
                "error": "",
            }
        
        update_progress(f"Verifying {len(claims)} claims", 60)
        
        # Critic: verify claims
        critique_results = critic.verify(claims, task=query)
        verified_count = sum(1 for r in critique_results if r.is_valid)
        
        update_progress("Synthesizing final report", 80)
        
        # Synthesize report
        context = {
            "report_title": f"HDRP Research Report: {query}",
            "introduction": (
                "This report was generated by the Hierarchical Deep Research Planner (HDRP) "
                "pipeline using structured claims with explicit source traceability."
            ),
        }
        report = synthesizer.synthesize(critique_results, context=context)
        
        update_progress("Completed", 100)
        
        return {
            "success": True,
            "run_id": actual_run_id,
            "report": report,
            "error": "",
            "stats": {
                "total_claims": len(claims),
                "verified_claims": verified_count,
                "rejected_claims": len(critique_results) - verified_count,
            }
        }
    
    except Exception as exc:
        return {
            "success": False,
            "run_id": actual_run_id,
            "report": "",
            "error": f"Unexpected error: {exc}",
        }


def main() -> None:
    """Entrypoint used by `python -m HDRP.cli` or a console_script."""
    app()


if __name__ == "__main__":
    main()